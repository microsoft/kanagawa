# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

# This file contains a set of unit tests to validate correct functionality
# of the Kanagawa standard library. The tests are run within the Verilator
# RTL simulator.

# Create a CMake target to build a library unit test. This function also
# creates a CTest target that can be used to run the test.
#
# Usage:
#   add_library_test(<test_name> <test_source>
#       [OPTIONS <opt1> <opt2> ...]
#       [TESTBENCH <path-to-systemverilog-file>]
#       [TESTBENCH_MODULE <systemverilog-module-name>]
#       [GENERATED_RTL <rtl-file1> <rtl-file2> ...]
#       [GROUP <1|2>]
#   )
#
#   test_name     - the name of the ctest that will be created. Note that the
#                   actual ctest name will be prefixed with 'library.'
#                   (i.e. library.test_name).
#   test_source   - a path to a Kanagawa source file that contains the test code
#   OPTIONS       - (optional) List of options to pass to the Kanagawa compiler
#   TESTBENCH     - (optional) SystemVerilog testbench file name (see note below).
#   TESTBENCH_MODULE -(optional) SystemVerilog testbench module name (default: Testbench)
#   GENERATED_RTL - (optional) - RTL files generated by the Kanagawa compiler that
#                   should be added to the verilator build. If not provided, the
#                   files corresponding to the default test runner will be used.
#   GROUP         - (optional) Test group number (1 or 2). Used to split tests across
#                   CI runners. Defaults to 1 for backward compatibility.
#
# If no value is provided for TESTBENCH, a default testbench in library/test/testbench.sv
# will be used. The default testbench is designed to work with a kanagawa test runner
# defined in library/test/runner.k.
#
# If the test requires a custom testbench the path to the SystemVerilog file containing
# that testbench must be provided via the TESTBENCH argument. The top-level (testbench)
# module in that file must be named "Testbench".
#
# The function creates a CMake target named library_test.${test_name} which you can use
# to build the test (both Kanagawa code generation and Verilator compilation).
#
function(add_library_test test_name test_source)
  set(_opts)
  set(_one TESTBENCH TESTBENCH_MODULE GROUP)
  set(_multi OPTIONS GENERATED_RTL)
  cmake_parse_arguments(_ARG "${_opts}" "${_one}" "${_multi}" ${ARGN})

  if (NOT test_name)
    message(FATAL_ERROR "add_library_test: missing <test_name> name as first argument.")
  endif()

  if (NOT test_source)
    message(FATAL_ERROR "add_library_test: missing <test_source> name as second argument.")
  endif()

  if (_ARG_TESTBENCH)
    set(_ARG_TESTBENCH "${CMAKE_CURRENT_SOURCE_DIR}/${_ARG_TESTBENCH}")
  endif()

  # Default to group 1 if not specified
  if (NOT _ARG_GROUP)
    set(_ARG_GROUP 1)
  endif()

  # Validate group number
  if (NOT _ARG_GROUP MATCHES "^[12]$")
    message(FATAL_ERROR "add_library_test: GROUP must be 1 or 2, got '${_ARG_GROUP}'")
  endif()

  # Clean Verilator byproducts in GitHub Actions to save disk space
  if(DEFINED ENV{GITHUB_ACTIONS})
    set(CLEAN_FLAG CLEAN_VERILATOR_BYPRODUCTS)
  else()
    set(CLEAN_FLAG)
  endif()

  add_kanagawa_verilator_test(${test_name}
    SCOPE "library.${_ARG_GROUP}"
    SOURCES ${test_source}
    OPTIONS ${_ARG_OPTIONS}
    GENERATED_RTL ${_ARG_GENERATED_RTL}
    TESTBENCH ${_ARG_TESTBENCH}
    TESTBENCH_MODULE ${_ARG_TESTBENCH_MODULE}
    AGGREGATE_TARGET library_tests_${_ARG_GROUP}
    ${CLEAN_FLAG}
  )
endfunction()

# Create group-specific aggregate targets
add_custom_target(library_tests_1)
add_custom_target(library_tests_2)

# Create uber-aggregate target that depends on both groups
add_custom_target(library_tests)
add_dependencies(library_tests library_tests_1 library_tests_2)

# Add a target to run group 1 tests
add_custom_target(run_library_tests_1
    COMMAND ${CMAKE_CTEST_COMMAND} --test-dir ${CMAKE_CURRENT_BINARY_DIR} -R "^library\\.1\\." --output-on-failure --verbose
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    DEPENDS library_tests_1
    COMMENT "Run library tests (group 1)"
    USES_TERMINAL
)

# Add a target to run group 2 tests
add_custom_target(run_library_tests_2
    COMMAND ${CMAKE_CTEST_COMMAND} --test-dir ${CMAKE_CURRENT_BINARY_DIR} -R "^library\\.2\\." --output-on-failure --verbose
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    DEPENDS library_tests_2
    COMMENT "Run library tests (group 2)"
    USES_TERMINAL
)

# Add a target to run all library tests
add_custom_target(run_library_tests
    COMMAND ${CMAKE_CTEST_COMMAND} --test-dir ${CMAKE_CURRENT_BINARY_DIR} -R "^library\\." --output-on-failure --verbose
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    DEPENDS library_tests
    COMMENT "Run all library tests"
    USES_TERMINAL
)

# Define library tests here

# Group 1

add_library_test(control_async control/async.k GROUP 1)
add_library_test(control_async_rendezvous_lenient control/async/rendezvous/lenient.k GROUP 1)
add_library_test(control_async_rendezvous_strict control/async/rendezvous/strict.k GROUP 1)
add_library_test(control_fsm control/fsm.k GROUP 1)
add_library_test(control_loop control/loop.k GROUP 1)
add_library_test(control_wait control/wait.k GROUP 1)
add_library_test(data_array data/array.k GROUP 1)
add_library_test(data_bits data/bits.k GROUP 1)
add_library_test(data_bitarray data/bitarray.k GROUP 1)
add_library_test(data_bitarray_banked data/bitarray/banked.k GROUP 1)
add_library_test(data_buffer data/buffer.k GROUP 1)
add_library_test(data_buffer_accumulating data/buffer/accumulating.k GROUP 1)
add_library_test(data_buffer_burst_write data/buffer/burst_write.k GROUP 1)
add_library_test(data_buffer_cyclic data/buffer/cyclic.k GROUP 1)
add_library_test(data_buffer_gearbox data/buffer/gearbox.k GROUP 1)
add_library_test(data_cache data/cache.k GROUP 1)
add_library_test(data_cache_write_only data/cache/write_only.k GROUP 1)
add_library_test(data_counter data/counter.k GROUP 1)
add_library_test(data_counter_saturating data/counter/saturating.k GROUP 1)
add_library_test(data_datetime data/datetime.k GROUP 1)
add_library_test(data_fifo_array data/fifo/array.k GROUP 1)
add_library_test(data_fifo_multi data/fifo/multi.k GROUP 1)
add_library_test(data_fifo_wide_to_narrow data/fifo/wide_to_narrow.k GROUP 1)
add_library_test(data_fifo_transpose data/fifo/transpose.k GROUP 1)
add_library_test(data_function data/function.k GROUP 1)
add_library_test(data_hash_table data/hash_table.k GROUP 1)
add_library_test(data_memory data/memory.k GROUP 1)
add_library_test(data_memory_bank_schedule data/memory/bank/schedule.k GROUP 1)
add_library_test(data_memory_pipelined data/memory/pipelined.k GROUP 1)
add_library_test(data_memory_unaligned data/memory/unaligned.k GROUP 1)
add_library_test(data_representation data/representation.k GROUP 1)
add_library_test(data_optional data/optional.k GROUP 1)
add_library_test(data_order data/order.k GROUP 1)
add_library_test(data_random_xoshiro data/random/xoshiro.k GROUP 1)
add_library_test(data_string data/string.k GROUP 1)
add_library_test(data_tuple data/tuple.k GROUP 1)
add_library_test(data_vector data/vector.k GROUP 1)

# Group 2

add_library_test(numeric_float numeric/float.k GROUP 2)
add_library_test(numeric_int numeric/int.k GROUP 2)
add_library_test(numeric_int_limits numeric/int/limits.k GROUP 2)
add_library_test(numeric_int_multi_word numeric/int/multi_word.k GROUP 2)
add_library_test(numeric_int_operator numeric/int/operator.k GROUP 2)
add_library_test(numeric_int_operator_modular numeric/int/operator/modular.k GROUP 2)
add_library_test(numeric_int_operator_unsigned numeric/int/operator/unsigned.k GROUP 2)
add_library_test(sync_atomic sync/atomic.k GROUP 2)
add_library_test(sync_lock sync/lock.k GROUP 2)
add_library_test(sync_lock_multi sync/lock/multi.k GROUP 2)
add_library_test(type_coerce type/coerce.k GROUP 2)

add_library_test(data_random_toeplitz_random data/random/toeplitz_random.k
  GROUP 2
  TESTBENCH
    data/random/toeplitz_random.sv
  GENERATED_RTL
    ToeplitzRandomWrapper_types.sv
    ToeplitzRandomWrapper.sv
)

add_library_test(data_random_toeplitz data/random/toeplitz.k
  GROUP 2
  TESTBENCH
    data/random/toeplitz.sv
  GENERATED_RTL
    ToeplitzWrapper_types.sv
    ToeplitzWrapper.sv
)

add_library_test(processor_risc_v_1_hart processor/risc-v.k
  GROUP 2
  OPTIONS
    "--define=mask#0x1FFF"
)

add_library_test(processor_risc_v_2_hart processor/risc-v.k
  GROUP 2
  OPTIONS
    "--define=mask#0x2FFF"
)

add_library_test(processor_risc_v_custom_instr processor/risc-v/custom-instr/custom-instr.k
  GROUP 2
  TESTBENCH
    processor/risc-v/custom-instr/custom-instr.sv
  GENERATED_RTL
    RISCVCustomInstrWrapper.sv
    RISCVCustomInstrWrapper_types.sv
)

add_library_test(processor_risc_v_mmio_1 processor/risc-v/mmio/mmio.k
  GROUP 2
  TESTBENCH
    processor/risc-v/mmio/mmio.sv
  OPTIONS
    "--define=HARTS#1"
  GENERATED_RTL
    RISCVMMIOWrapper.sv
    RISCVMMIOWrapper_types.sv)

add_library_test(processor_risc_v_mmio_2 processor/risc-v/mmio/mmio.k
  GROUP 2
  TESTBENCH
    processor/risc-v/mmio/mmio.sv
  OPTIONS "--define=HARTS#2"
  GENERATED_RTL
    RISCVMMIOWrapper.sv
    RISCVMMIOWrapper_types.sv
)

add_library_test(processor_risc_v_mmio_4 processor/risc-v/mmio/mmio.k
  GROUP 2
  TESTBENCH
    processor/risc-v/mmio/mmio.sv
  OPTIONS
    "--define=HARTS#4"
  GENERATED_RTL
    RISCVMMIOWrapper.sv
    RISCVMMIOWrapper_types.sv
)

add_subdirectory(processor)