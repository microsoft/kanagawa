// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//| Copyright: (c) Microsoft Corporation. All rights reserved.
module numeric.int.multi_word
    { add_with_carry,
      sub_with_borrow,
      min_with_metadata,
      max_with_metadata,
      get_initial_comp_metadata
    }

import numeric.int.multi_word.internal

//| Return the sum and carry generated by adding  `a`, `b`, and `carry`.
//  Expected iteration order while calling this over multiple words: Least significant to most significant
template
    < typename T //< Type of values to be added
    >
inline pair<T, uint1> add_with_carry
    ( T a //< The first operand for addition
    , T b //< The second operand for addition
    , uint1 carry //< The input carry
    )
{ 
    // The sum with carry can be computed by expression: a + b + carry
    // but that will generate two T bit adders. The expression below 
    // uses only one T+1 bit adder. The LSB of left operand of '+' 
    // below is 1 and LSB of the second operand is carry. Due to their
    // addition, the incoming carry for LSB of a and b is same as the 
    // carry passed as paramter. The final right shift removes the 
    // sum of 1 and carry from the result.
    auto sum_w_carry = (((a << 1) | 1) + ((b << 1) | carry)) >> 1;
    auto carry_out = cast<uint1>(sum_w_carry >> bitsizeof(T));
    auto sum = cast<T>(sum_w_carry);
    return make_pair(sum, carry_out);
}

//| Return the difference and borrow generated by subtracting `a`, `b`, and `borrow`.
//  Expected iteration order while calling this over multiple words: Least significant to most significant
template
    < typename T //< Type of values to be subtracted
    >
inline pair<T, uint1> sub_with_borrow
    ( T a //< The first operand for subtraction
    , T b //< The second operand for subtraction
    , uint1 borrow //< The input borrow
    )
{ 
    // The sub with borrow can be computed by expression: a - b - borrow
    // but that will generate two T bit subtractors. The expression below 
    // uses only one T+1 bit subtractor. The LSB of left operand of '-' 
    // below is 0 and LSB of the second operand is borrow. Due to their
    // subtraction, the incoming borrow for LSB of a and b is same as the 
    // borrow passed as paramter. The final right shift removes the 
    // subtraction of 0 and borrow from the result.
    auto sub_w_borrow = ((a << 1) - ((b << 1) | borrow)) >> 1;
    auto borrow_out = cast<uint1>(sub_w_borrow >> bitsizeof(T));
    auto sub = cast<T>(sub_w_borrow);
    return make_pair(sub, borrow_out);
}


//| Returns the metadata to be passed to the first call to `min_with_metadata` and `max_with_metadata`.
inline comp_metadata get_initial_comp_metadata()
{
    return {true, true};
}

//| This function is used while computing min of two multi-word variables a_words and b_words, to which a and b belong.
//  It selects `a` if a_words < b_words, or `b` if b_words < a_words. It also returns the metadata to be used as incoming
//  metadata for the next call to this function.
//  Expected iteration order while calling this over multiple words: Most significant to least significant
template
    < typename T //< Type of the words
    >
inline pair<T, comp_metadata> min_with_metadata
    ( T a //< The first operand for min
    , T b //< The second operand for min
    , comp_metadata prev_metadata //< The incoming metadata
    )
{
    
    T ret_word = prev_metadata.all_previous_words_eq ?
                    a < b ? a : b
                 :  prev_metadata.select_a_words_on_prevnoteq ? a : b;
    comp_metadata ret_metadata;
    bool eq_a_b = a == b;
    ret_metadata.all_previous_words_eq = prev_metadata.all_previous_words_eq && eq_a_b;
    ret_metadata.select_a_words_on_prevnoteq = !prev_metadata.all_previous_words_eq ?
                                                     prev_metadata.select_a_words_on_prevnoteq
                                                :    !eq_a_b ? a < b : prev_metadata.select_a_words_on_prevnoteq;
    return make_pair(ret_word, ret_metadata);
}

//| This function is used while computing max of two multi-word variables a_words and b_words, to which a and b belong.
//  It selects `a` if a_words > b_words, or `b` if b_words > a_words. It also returns the metadata to be used as incoming
//  metadata for the next call to this function.
//  Expected iteration order while calling this over multiple words: Most significant to least significant
template
    < typename T //< Type of the words
    >
inline pair<T, comp_metadata> max_with_metadata
    ( T a //< The first operand for max
    , T b //< The second operand for max
    , comp_metadata prev_metadata //< The incoming metadata
    )
{
    
    T ret_word = prev_metadata.all_previous_words_eq ?
                    a > b ? a : b
                 :  prev_metadata.select_a_words_on_prevnoteq ? a : b;
    comp_metadata ret_metadata;
    bool eq_a_b = a == b;
    ret_metadata.all_previous_words_eq = prev_metadata.all_previous_words_eq && eq_a_b;
    ret_metadata.select_a_words_on_prevnoteq = !prev_metadata.all_previous_words_eq ?
                                                     prev_metadata.select_a_words_on_prevnoteq
                                                :    !eq_a_b ? a > b : prev_metadata.select_a_words_on_prevnoteq;
    return make_pair(ret_word, ret_metadata);
}